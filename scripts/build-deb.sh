#!/bin/bash
set -ex

# This function is called on exit to clean up build artifacts.
cleanup() {
    echo "--- Cleaning up build artifacts ---"
    # Revert the changelog to its state in Git.
    git checkout -- debian/changelog
    # Remove all temporary files generated by debhelper.
    rm -f debian/*.substvars debian/*.debhelper.log debian/debhelper-build-stamp debian/files
    # Remove the debhelper cache directory.
    rm -rf debian/.debhelper
    # Remove generated package files from the debian directory.
    rm -rf debian/rayforge*
    echo "Cleanup complete."
}

# The trap command ensures that the cleanup function is called when the script exits,
# for any reason (success, failure, or interrupt).
trap cleanup EXIT

# === Prerequisite Check ===
REQUIRED_TOOLS="dch debuild"
for tool in $REQUIRED_TOOLS; do
  if ! command -v "$tool" &> /dev/null; then
    echo "Error: Required command '$tool' not found."
    echo "Please install the Debian packaging tools on your system:"
    echo "sudo apt update && sudo apt install devscripts"
    exit 1
  fi
done

# === Prepare Environment for dch ===
# dch requires DEBEMAIL and DEBFULLNAME to be set to avoid interactive prompts.
# We parse these from the authoritative debian/control file to keep things DRY.
MAINTAINER_INFO=$(grep '^Maintainer:' debian/control | head -n 1 | sed 's/Maintainer: //')
export DEBEMAIL=$(echo "$MAINTAINER_INFO" | sed 's/.*<\(.*\)>.*/\1/')
export DEBFULLNAME=$(echo "$MAINTAINER_INFO" | sed 's/ <.*//')

# Sanity check to ensure parsing was successful.
if [ -z "$DEBEMAIL" ] || [ -z "$DEBFULLNAME" ]; then
    echo "Error: Could not parse Maintainer information from debian/control."
    echo "Please ensure it is in the format 'Your Name <your.email@example.com>'"
    exit 1
fi

# === Build Logic ===

# Check for a --source flag.
BUILD_SOURCE=false
if [ "$1" == "--source" ]; then
    BUILD_SOURCE=true
fi

# --- Dynamic Version Detection ---
if [[ -n "$GITHUB_REF_NAME" && "$GITHUB_REF_TYPE" == "tag" ]]; then
  VERSION_RAW="$GITHUB_REF_NAME"
else
  VERSION_RAW=$(git describe --tags --always | sed -e 's/-/./g' -e 's/^v//' -e 's/g/git/')
fi
VERSION="${VERSION_RAW#v}"
echo "Detected package version: ${VERSION}"

# --- Update Changelog (now non-interactively) ---
if [ "$BUILD_SOURCE" = true ]; then
  dch --newversion "${VERSION}-1~ppa1" "New PPA release ${VERSION}."
else
  dch --newversion "${VERSION}-1~local1" "New local build ${VERSION}."
fi

# --- Build the Package ---
if [ "$BUILD_SOURCE" = true ]; then
    echo "Building SIGNED SOURCE package for PPA..."
    GPG_KEY_ID=$(gpg --list-secret-keys --with-colons | grep '^sec:' | cut -d: -f5)
    
    # Check for the GPG key
    if [ -z "$GPG_KEY_ID" ]; then
        echo "Error: Could not find a GPG secret key for signing."
        echo "Please ensure the PPA_GPG_PRIVATE_KEY secret is set correctly."
        exit 1
    fi
    
    debuild -S -k"${GPG_KEY_ID}"
    echo "Source package built successfully. Find it in the parent directory."
else
    echo "Building UNSIGNED BINARY package for local testing..."
    debuild -b -us -uc
    echo "Binary package built successfully. Find it in the parent directory."
fi
